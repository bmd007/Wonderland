/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package wonderland.game.client;

import com.jme3.app.SimpleApplication;
import com.jme3.bullet.BulletAppState;
import com.jme3.bullet.collision.shapes.CapsuleCollisionShape;
import com.jme3.bullet.collision.shapes.CollisionShape;
import com.jme3.bullet.control.CharacterControl;
import com.jme3.bullet.control.RigidBodyControl;
import com.jme3.bullet.objects.PhysicsCharacter;
import com.jme3.bullet.util.CollisionShapeFactory;
import com.jme3.collision.CollisionResult;
import com.jme3.collision.CollisionResults;
import com.jme3.cursors.plugins.JmeCursor;
import com.jme3.font.BitmapText;
import com.jme3.input.KeyInput;
import com.jme3.input.MouseInput;
import com.jme3.input.controls.ActionListener;
import com.jme3.input.controls.AnalogListener;
import com.jme3.input.controls.KeyTrigger;
import com.jme3.input.controls.MouseAxisTrigger;
import com.jme3.input.controls.MouseButtonTrigger;
import com.jme3.light.DirectionalLight;
import com.jme3.material.Material;
import com.jme3.math.ColorRGBA;
import com.jme3.math.Ray;
import com.jme3.math.Vector2f;
import com.jme3.math.Vector3f;
import com.jme3.scene.Geometry;
import com.jme3.scene.Node;
import com.jme3.scene.Spatial;
import com.jme3.scene.shape.Sphere;
import com.jme3.system.AppSettings;
import org.springframework.messaging.rsocket.RSocketRequester;
import reactor.core.publisher.Flux;

import java.util.Optional;
import java.util.concurrent.ConcurrentLinkedQueue;

public class App extends SimpleApplication {

    private Spatial sniperSpatial;
    private final Node shootables = new Node("Shootables");
    private Geometry mark;
    private Spatial sceneModel;

    static ConcurrentLinkedQueue<Rocket> localValues = new ConcurrentLinkedQueue<>();

    private static Flux<Rocket> rockets = RSocketRequester.builder()
//            .rsocketConnector(connector -> connector.reconnect(Retry.fixedDelay(2, Duration.ofSeconds(2))))
            .tcp("localhost", 4789)
            .route("rocket")
            .data("abc")
            .retrieveFlux(String.class)
            .map(value -> value.split(":"))
            .filter(values -> values.length == 2)
            .map(values -> new Rocket(Integer.valueOf(values[0]), Integer.valueOf(values[1])))
            .doOnNext(localValues::add);
    //    app.enqueue(callable);


    public static void main(String[] args) {
//        rockets.subscribe();
        App app = new App();
        AppSettings settings = new AppSettings(true);
        settings.setTitle("My Awesome Game");
        app.setSettings(settings);
        app.start();
    }
    private BulletAppState bulletAppState;
    private RigidBodyControl landscape;
    private CharacterControl player;
    private final Vector3f toBeUpdatedWalkDirection = new Vector3f();
    private boolean left = false, right = false, fowrad = false, backward = false;
    private final Vector3f tempPlayerWalkDirection = new Vector3f();
    private final Vector3f tempPlayerViewDirection = new Vector3f();
    private final ActionListener actionListener = (binding, isPressed, tpf) -> {
        if (binding.equals("Shoot") && !isPressed) {
            CollisionResults results = new CollisionResults();
            Vector2f click2d = inputManager.getCursorPosition().clone();
            Vector3f click3d = cam.getWorldCoordinates(click2d, 0f).clone();
            Vector3f dir = cam.getWorldCoordinates(click2d, 1f).subtractLocal(click3d).normalizeLocal();//todo what the hell
            Ray ray = new Ray(click3d, dir);
            shootables.collideWith(ray, results);
            if (results.size() > 0) {
                CollisionResult closest = results.getClosestCollision();
                mark.setLocalTranslation(closest.getContactPoint());
                rootNode.attachChild(mark);
                Optional.ofNullable(closest.getGeometry().getControl(CharacterControl.class)).ifPresent(PhysicsCharacter::jump);
                Optional.ofNullable(closest.getGeometry().getControl(RigidBodyControl.class))
                        .ifPresent(rigidBodyControl -> rigidBodyControl.applyCentralForce(new Vector3f(0, 3f, 4f)));
            } else {
                rootNode.detachChild(mark);
            }
        } else if (binding.equals("Jump")) {
            if (isPressed) {
                player.jump();
            }
        } else if (binding.equals("Left")) {
            left = isPressed;
            right = false;
            fowrad = false;
            backward = false;
        } else if (binding.equals("Right")) {
            left = false;
            right = isPressed;
            fowrad = false;
            backward = false;
        } else if (binding.equals("Forward")) {
            left = false;
            right = false;
            fowrad = isPressed;
            backward = false;
        } else if (binding.equals("Backward")) {
            left = false;
            right = false;
            fowrad = false;
            backward = isPressed;
        }
    };
    private final AnalogListener analogListener = (binding, intensity, tpf) -> {
        if (binding.equals("rotate")){
//            sniperSpatial.rotate(0, intensity, 0);
//            sniperSpatial.setLocalRotation(new Quaternion().fromAngleAxis(intensity, UNIT_Y));
        }
    };

    @Override
    public void simpleInitApp() {
        bulletAppState = new BulletAppState();
        stateManager.attach(bulletAppState);

        // You must add a light to make the model visible
        DirectionalLight sun = new DirectionalLight();
        sun.setDirection(new Vector3f(-0.1f, -0.7f, -1.0f));
        rootNode.addLight(sun);

        sceneModel = assetManager.loadModel("assets/simple_house/house.obj");
        CollisionShape sceneShape = CollisionShapeFactory.createMeshShape(sceneModel);
        landscape = new RigidBodyControl(sceneShape, 0);
        sceneModel.addControl(landscape);
        rootNode.attachChild(sceneModel);
        bulletAppState.getPhysicsSpace().add(landscape);

//        rootNode.attachChild(shootables);

//        Spatial enemy = assetManager.loadModel("Models/sniper/OBJ.obj");
//        enemy.scale(5f);
//        var enemyRadius = enemy.getWorldScale().getX()/2;
//        var enemyHeight = enemy.getWorldScale().getY()/2;
//        CapsuleCollisionShape enemyCapsuleShape = new CapsuleCollisionShape(enemyRadius, enemyHeight, 1);
//        CharacterControl enemyCharacterControl = new CharacterControl(enemyCapsuleShape, 0.02f);
//        enemyCharacterControl.setGravity(30f);
//        enemyCharacterControl.setJumpSpeed(30);
//        enemy.addControl(enemyCharacterControl);
//        enemyCharacterControl.setPhysicsLocation(new Vector3f(-150f, 6f, -100f));
//        bulletAppState.getPhysicsSpace().add(enemyCharacterControl);

//        shootables.attachChild(enemy);

//        Spatial lara = assetManager.loadModel("Models/lara/lara_max_2010_OBJ.obj");
//        lara.setLocalTranslation(-200, 0, -345);
//        lara.scale(0.004f);
//        shootables.attachChild(lara);

//        sniperSpatial = assetManager.loadModel("Models/soldier/OBJ.obj");
//        sniperSpatial.scale(4f);
//        var sniperRadius = sniperSpatial.getLocalScale().getX() / 2;
//        var sniperHeight = sniperSpatial.getLocalScale().getY() / 2;
//        CapsuleCollisionShape capsuleShape = new CapsuleCollisionShape(sniperRadius, sniperHeight, 1);
//        player = new CharacterControl(capsuleShape, 0.02f);
//        player.setJumpSpeed(30);
//        player.setFallSpeed(30);
//        player.setGravity(30f);
//        sniperSpatial.addControl(player);
//        player.setPhysicsLocation(new Vector3f(-150f, 0f, -100f));
//        rootNode.attachChild(sniperSpatial);
//        bulletAppState.setDebugEnabled(true);
//        bulletAppState.getPhysicsSpace().add(player);


//        flyCam.setEnabled(false);
//        initCrossHairs();
//        initMark();

//        inputManager.addMapping("Left", new KeyTrigger(KeyInput.KEY_A));
//        inputManager.addMapping("Right", new KeyTrigger(KeyInput.KEY_D));
//        inputManager.addMapping("Forward", new KeyTrigger(KeyInput.KEY_W));
//        inputManager.addMapping("Backward", new KeyTrigger(KeyInput.KEY_S));
//        inputManager.addMapping("Jump", new KeyTrigger(KeyInput.KEY_SPACE));
//        inputManager.addMapping("Shoot", new MouseButtonTrigger(MouseInput.BUTTON_LEFT));
//        inputManager.addListener(actionListener, "Left", "Right", "Forward", "Backward", "Shoot", "Jump");
//
//        inputManager.addMapping("rotate", new MouseAxisTrigger(MouseInput.AXIS_Y, false), new KeyTrigger(KeyInput.KEY_R) );
//        inputManager.addListener(analogListener, new String[]{"rotate"});
    }

    protected void initMark() {
        Sphere sphere = new Sphere(30, 30, 0.2f);
        mark = new Geometry("BOOM!", sphere);
        Material mark_mat = new Material(assetManager, "Common/MatDefs/Misc/Unshaded.j3md");
        mark_mat.setColor("Color", ColorRGBA.Red);
        mark.setMaterial(mark_mat);
    }

    protected void initCrossHairs() {
        inputManager.setCursorVisible(true);
//        setDisplayStatView(false);
        guiFont = assetManager.loadFont("Interface/Fonts/Default.fnt");
        BitmapText ch = new BitmapText(guiFont);
        ch.setSize(guiFont.getCharSet().getRenderedSize() * 2);
        ch.setText("+");
        ch.setLocalTranslation( // center
                settings.getWidth() / 2 - ch.getLineWidth() / 2,
                settings.getHeight() / 2 + ch.getLineHeight() / 2, 0);
        inputManager.setMouseCursor((JmeCursor) assetManager.loadAsset("Textures/Cursors/meme.cur"));
    }

    @Override
    public void simpleUpdate(float tpf) {
//        tempPlayerWalkDirection.set(sniperSpatial.getWorldRotation().getRotationColumn(2)).multLocal(0.6f);
//        tempPlayerViewDirection.set(sniperSpatial.getWorldRotation().getRotationColumn(0)).multLocal(0.4f);
//        toBeUpdatedWalkDirection.set(0, 0, 0);
//        if (left) {
//            toBeUpdatedWalkDirection.addLocal(tempPlayerViewDirection.negate());
//        }
//        if (right) {
//            toBeUpdatedWalkDirection.addLocal(tempPlayerViewDirection);
//        }
//        if (fowrad) {
//            toBeUpdatedWalkDirection.addLocal(tempPlayerWalkDirection.negate());
//        }
//        if (backward) {
//            toBeUpdatedWalkDirection.addLocal(tempPlayerWalkDirection);
//        }
//        player.setWalkDirection(toBeUpdatedWalkDirection);
//        cam.setLocation(player.getPhysicsLocation().add(new Vector3f(-5, 7f, 30f)));
    }

    record Rocket(int x, int y) {
    }
}
